{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Course motivation","title":"Course motivation"},{"location":"#course-motivation","text":"","title":"Course motivation"},{"location":"training/extra/async-parallel/01/","text":"Example 1 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : 1st sleep command : sleep 5 - name : 2nd sleep command : sleep 5 - name : 3rd sleep command : sleep 5 - name : 4th sleep command : sleep 5 - name : 5th sleep command : sleep 5 Tip Ansible's performance may depend on a variety of different factors. Always try to optimize your scripts for reduced time consumption. Execute the following command time ansible-playbook playbook.yml Bonus round Disale fact gathering and check how it impacts Ansible's performance.","title":"Example 1"},{"location":"training/extra/async-parallel/01/#example-1","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : 1st sleep command : sleep 5 - name : 2nd sleep command : sleep 5 - name : 3rd sleep command : sleep 5 - name : 4th sleep command : sleep 5 - name : 5th sleep command : sleep 5 Tip Ansible's performance may depend on a variety of different factors. Always try to optimize your scripts for reduced time consumption. Execute the following command time ansible-playbook playbook.yml Bonus round Disale fact gathering and check how it impacts Ansible's performance.","title":"Example 1"},{"location":"training/extra/async-parallel/02/","text":"Example 2 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all gather_facts : false tasks : - name : 1st sleep command : sleep 5 when : inventory_hostname == 'provisioner' - name : 2nd sleep command : sleep 5 when : inventory_hostname == 'centos1' - name : 3rd sleep command : sleep 5 when : inventory_hostname == 'ubuntu1' - name : 4th sleep command : sleep 5 when : inventory_hostname == 'provisioner' - name : 5th sleep command : sleep 5 when : inventory_hostname == 'centos1' Tip Ansible's parallelism, by default, is limited to the task level and a predefined number of forks . Execute the following command time ansible-playbook playbook.yml Do you expect to see improved results compared to Example 1? No, because we will still have to wait for the task to finish on the assigned host during each step.","title":"Example 2"},{"location":"training/extra/async-parallel/02/#example-2","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all gather_facts : false tasks : - name : 1st sleep command : sleep 5 when : inventory_hostname == 'provisioner' - name : 2nd sleep command : sleep 5 when : inventory_hostname == 'centos1' - name : 3rd sleep command : sleep 5 when : inventory_hostname == 'ubuntu1' - name : 4th sleep command : sleep 5 when : inventory_hostname == 'provisioner' - name : 5th sleep command : sleep 5 when : inventory_hostname == 'centos1' Tip Ansible's parallelism, by default, is limited to the task level and a predefined number of forks . Execute the following command time ansible-playbook playbook.yml Do you expect to see improved results compared to Example 1? No, because we will still have to wait for the task to finish on the assigned host during each step.","title":"Example 2"},{"location":"training/extra/async-parallel/03/","text":"Example 3 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all gather_facts : false tasks : - name : 1st sleep command : sleep 20 when : inventory_hostname == 'provisioner' async : 45 poll : 0 - name : 2nd sleep command : sleep 5 when : inventory_hostname == 'centos1' async : 10 poll : 0 - name : 3rd sleep command : sleep 5 when : inventory_hostname == 'ubuntu1' async : 10 poll : 0 - name : 4th sleep command : sleep 5 when : inventory_hostname == 'provisioner' async : 10 poll : 0 - name : 5th sleep command : sleep 5 when : inventory_hostname == 'centos1' async : 10 poll : 0 Tip The user can introduce the fire & forget behavior using async and poll directives. Execute the following command time ansible-playbook playbook.yml Do you expect to see improved results compared to Example 1? Yes, because Ansible will exit before the tasks are actually finished running.","title":"Example 3"},{"location":"training/extra/async-parallel/03/#example-3","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all gather_facts : false tasks : - name : 1st sleep command : sleep 20 when : inventory_hostname == 'provisioner' async : 45 poll : 0 - name : 2nd sleep command : sleep 5 when : inventory_hostname == 'centos1' async : 10 poll : 0 - name : 3rd sleep command : sleep 5 when : inventory_hostname == 'ubuntu1' async : 10 poll : 0 - name : 4th sleep command : sleep 5 when : inventory_hostname == 'provisioner' async : 10 poll : 0 - name : 5th sleep command : sleep 5 when : inventory_hostname == 'centos1' async : 10 poll : 0 Tip The user can introduce the fire & forget behavior using async and poll directives. Execute the following command time ansible-playbook playbook.yml Do you expect to see improved results compared to Example 1? Yes, because Ansible will exit before the tasks are actually finished running.","title":"Example 3"},{"location":"training/extra/async-parallel/04/","text":"Example 4 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all gather_facts : false vars : jobs : [] tasks : - name : 1st sleep command : sleep 20 when : inventory_hostname == 'provisioner' async : 45 poll : 0 register : out1 - name : 2nd sleep command : sleep 5 when : inventory_hostname == 'centos1' async : 10 poll : 0 register : out2 - name : 3rd sleep command : sleep 5 when : inventory_hostname == 'ubuntu1' async : 10 poll : 0 register : out3 - name : 4th sleep command : sleep 5 when : inventory_hostname == 'provisioner' async : 10 poll : 0 register : out4 - name : 5th sleep command : sleep 5 when : inventory_hostname == 'centos1' async : 10 poll : 0 register : out5 - name : Capture started jobs set_fact : jobs : > {% if item.ansible_job_id is defined -%} {{ jobs + [item.ansible_job_id] }} {% else -%} {{ jobs }} {% endif -%} with_items : - \"{{ out1 }}\" - \"{{ out2 }}\" - \"{{ out3 }}\" - \"{{ out4 }}\" - \"{{ out5 }}\" - name : Show jobs debug : var : jobs Tip The user can register the job id's of started tasks in order to implement more complex behavior. Execute the following command ansible-playbook playbook.yml Bonus round Use Ansible's async_status module to wait for all the jobs to finish.","title":"Example 4"},{"location":"training/extra/async-parallel/04/#example-4","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all gather_facts : false vars : jobs : [] tasks : - name : 1st sleep command : sleep 20 when : inventory_hostname == 'provisioner' async : 45 poll : 0 register : out1 - name : 2nd sleep command : sleep 5 when : inventory_hostname == 'centos1' async : 10 poll : 0 register : out2 - name : 3rd sleep command : sleep 5 when : inventory_hostname == 'ubuntu1' async : 10 poll : 0 register : out3 - name : 4th sleep command : sleep 5 when : inventory_hostname == 'provisioner' async : 10 poll : 0 register : out4 - name : 5th sleep command : sleep 5 when : inventory_hostname == 'centos1' async : 10 poll : 0 register : out5 - name : Capture started jobs set_fact : jobs : > {% if item.ansible_job_id is defined -%} {{ jobs + [item.ansible_job_id] }} {% else -%} {{ jobs }} {% endif -%} with_items : - \"{{ out1 }}\" - \"{{ out2 }}\" - \"{{ out3 }}\" - \"{{ out4 }}\" - \"{{ out5 }}\" - name : Show jobs debug : var : jobs Tip The user can register the job id's of started tasks in order to implement more complex behavior. Execute the following command ansible-playbook playbook.yml Bonus round Use Ansible's async_status module to wait for all the jobs to finish.","title":"Example 4"},{"location":"training/extra/async-parallel/05/","text":"Example 5 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all gather_facts : false serial : 2 tasks : - name : 1st sleep command : sleep 1 - name : 2nd sleep command : sleep 1 - name : 3rd sleep command : sleep 1 - name : 4th sleep command : sleep 1 - name : 5th sleep command : sleep 1 Tip Ansible's default execution strategy is linear , where each task needs to complete on all remotes before proceeding to the next one. You can batch tasks using the serial directive in order to run them on a subset of your remote hosts. Execute the following command ansible-playbook playbook.yml Bonus round Substitute the serial: 2 directive from the playbook with strategy: free and measure the time performance. The free strategy allows all hosts to run towards the end of the playbook as fast as they can.","title":"Example 5"},{"location":"training/extra/async-parallel/05/#example-5","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all gather_facts : false serial : 2 tasks : - name : 1st sleep command : sleep 1 - name : 2nd sleep command : sleep 1 - name : 3rd sleep command : sleep 1 - name : 4th sleep command : sleep 1 - name : 5th sleep command : sleep 1 Tip Ansible's default execution strategy is linear , where each task needs to complete on all remotes before proceeding to the next one. You can batch tasks using the serial directive in order to run them on a subset of your remote hosts. Execute the following command ansible-playbook playbook.yml Bonus round Substitute the serial: 2 directive from the playbook with strategy: free and measure the time performance. The free strategy allows all hosts to run towards the end of the playbook as fast as they can.","title":"Example 5"},{"location":"training/extra/blocks/01/","text":"Example 1 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Block of executed modules block : - name : Example 1 debug : msg : This is Example 1 - name : Example 2 debug : msg : This is Example 2 - name : Example 3 debug : msg : This is Example 3 Tip In order to group tasks that are somwhow linked together the user can apply the block directive. Execute the following command ansible-playbook playbook.yml","title":"Example 1"},{"location":"training/extra/blocks/01/#example-1","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Block of executed modules block : - name : Example 1 debug : msg : This is Example 1 - name : Example 2 debug : msg : This is Example 2 - name : Example 3 debug : msg : This is Example 3 Tip In order to group tasks that are somwhow linked together the user can apply the block directive. Execute the following command ansible-playbook playbook.yml","title":"Example 1"},{"location":"training/extra/blocks/02/","text":"Example 2 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Block of executed modules block : - name : Example 1 debug : msg : This is Example 1 - name : Example 2 debug : msg : This is Example 2 - name : Example 3 debug : msg : This is Example 3 when : ansible_distribution == \"CentOS\" Tip Blocks can be used to apply when and with_<lookup> directives to multiple tasks. Execute the following command ansible-playbook playbook.yml","title":"Example 2"},{"location":"training/extra/blocks/02/#example-2","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Block of executed modules block : - name : Example 1 debug : msg : This is Example 1 - name : Example 2 debug : msg : This is Example 2 - name : Example 3 debug : msg : This is Example 3 when : ansible_distribution == \"CentOS\" Tip Blocks can be used to apply when and with_<lookup> directives to multiple tasks. Execute the following command ansible-playbook playbook.yml","title":"Example 2"},{"location":"training/extra/blocks/03/","text":"Example 3 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Block of executed modules block : - name : Copy into /etc as unprivilaged user copy : content : Some content dest : /etc/test.txt rescue : - name : Copy to /home/vagrant instead copy : content : Some content dest : /home/vagrant/test.txt always : - debug : msg : Always runs, .. well always!!! Tip Special blocks , such as rescue and always can be used to emulate try/except/finally behavior. Execute the following command ansible-playbook playbook.yml","title":"Example 3"},{"location":"training/extra/blocks/03/#example-3","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Block of executed modules block : - name : Copy into /etc as unprivilaged user copy : content : Some content dest : /etc/test.txt rescue : - name : Copy to /home/vagrant instead copy : content : Some content dest : /home/vagrant/test.txt always : - debug : msg : Always runs, .. well always!!! Tip Special blocks , such as rescue and always can be used to emulate try/except/finally behavior. Execute the following command ansible-playbook playbook.yml","title":"Example 3"},{"location":"training/extra/jinja2/01/","text":"Example 1 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 if statement debug : msg : > {# This is a comment in Jinja2 -#} {% if ansible_distribution == \"CentOS\" -%} This machine runs on CentOS {% endif %} Tip Jinja2 syntax can be used inside the playbooks to introduce addtional versatility. Execute the following command ansible-playbook playbook.yml","title":"Example 1"},{"location":"training/extra/jinja2/01/#example-1","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 if statement debug : msg : > {# This is a comment in Jinja2 -#} {% if ansible_distribution == \"CentOS\" -%} This machine runs on CentOS {% endif %} Tip Jinja2 syntax can be used inside the playbooks to introduce addtional versatility. Execute the following command ansible-playbook playbook.yml","title":"Example 1"},{"location":"training/extra/jinja2/02/","text":"Example 2 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 if/elif statement debug : msg : > {# This is a comment in Jinja2 -#} {% if ansible_distribution == \"CentOS\" -%} This machine runs on CentOS {% elif ansible_distribution == \"Ubuntu\" -%} This machine runs on Ubuntu {% endif %} Tip Thanks to Jinja2 if/else/elif statements can be incorporated directly into system calls. Execute the following command ansible-playbook playbook.yml","title":"Example 2"},{"location":"training/extra/jinja2/02/#example-2","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 if/elif statement debug : msg : > {# This is a comment in Jinja2 -#} {% if ansible_distribution == \"CentOS\" -%} This machine runs on CentOS {% elif ansible_distribution == \"Ubuntu\" -%} This machine runs on Ubuntu {% endif %} Tip Thanks to Jinja2 if/else/elif statements can be incorporated directly into system calls. Execute the following command ansible-playbook playbook.yml","title":"Example 2"},{"location":"training/extra/jinja2/03/","text":"Example 3 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 if/else statement debug : msg : > {# This is a comment in Jinja2 -#} {% if ansible_distribution == \"CentOS\" -%} This is one of CentOS VMs - {{ ansible_hostname }} {% else -%} This is one of Ubunut VMs - {{ ansible_hostname }} {% endif %} Tip Jinja2 blocks can be combined with internal Ansible variables to match more complex scenarios. Execute the following command ansible-playbook playbook.yml","title":"Example 3"},{"location":"training/extra/jinja2/03/#example-3","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 if/else statement debug : msg : > {# This is a comment in Jinja2 -#} {% if ansible_distribution == \"CentOS\" -%} This is one of CentOS VMs - {{ ansible_hostname }} {% else -%} This is one of Ubunut VMs - {{ ansible_hostname }} {% endif %} Tip Jinja2 blocks can be combined with internal Ansible variables to match more complex scenarios. Execute the following command ansible-playbook playbook.yml","title":"Example 3"},{"location":"training/extra/jinja2/04/","text":"Example 4 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 if/else statement debug : msg : > {% set some_var = 'some_value' -%} {# This is a comment in Jinja2 -#} {% if some_var is defined -%} some_var is defined {% else -%} some_var is not_defined {% endif %} Tip Jinja2 allows the user to set task-scoped vars . Execute the following command ansible-playbook playbook.yml Bonus round Check how Jinja2 deals with playbook-scoped vars by modyfing the playbook.","title":"Example 4"},{"location":"training/extra/jinja2/04/#example-4","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 if/else statement debug : msg : > {% set some_var = 'some_value' -%} {# This is a comment in Jinja2 -#} {% if some_var is defined -%} some_var is defined {% else -%} some_var is not_defined {% endif %} Tip Jinja2 allows the user to set task-scoped vars . Execute the following command ansible-playbook playbook.yml Bonus round Check how Jinja2 deals with playbook-scoped vars by modyfing the playbook.","title":"Example 4"},{"location":"training/extra/jinja2/05/","text":"Example 5 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 for loop debug : msg : > {% for entry in ansible_all_ipv4_addresses -%} IPv4 address {{ loop.index }} = {{ entry }} {% endfor %} Tip Jinja2 allows the user to create complex loops in task scope. Execute the following command ansible-playbook playbook.yml","title":"Example 5"},{"location":"training/extra/jinja2/05/#example-5","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 for loop debug : msg : > {% for entry in ansible_all_ipv4_addresses -%} IPv4 address {{ loop.index }} = {{ entry }} {% endfor %} Tip Jinja2 allows the user to create complex loops in task scope. Execute the following command ansible-playbook playbook.yml","title":"Example 5"},{"location":"training/extra/jinja2/06/","text":"Example 6 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 filters debug : msg : > ...min... {{ [1, 2, 3] | min }} ...max... {{ [1, 2, 3] | max }} ...unique... {{ [1, 1, 1, 2, 2 ,3] | unique }} ...random.. {{ [1, 2, 3, 4, 5] | random }} Tip Jinja2 comes with multiple built-in filters that help with a variety of common templating patterns. Execute the following command ansible-playbook playbook.yml","title":"Example 6"},{"location":"training/extra/jinja2/06/#example-6","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - hosts : all tasks : - name : Jinja2 filters debug : msg : > ...min... {{ [1, 2, 3] | min }} ...max... {{ [1, 2, 3] | max }} ...unique... {{ [1, 1, 1, 2, 2 ,3] | unique }} ...random.. {{ [1, 2, 3, 4, 5] | random }} Tip Jinja2 comes with multiple built-in filters that help with a variety of common templating patterns. Execute the following command ansible-playbook playbook.yml","title":"Example 6"},{"location":"training/extra/loops/01/","text":"Example 1 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all become : true tasks : - name : Set SSH message of the day (motd) copy : content : \"Working on: {{ ansible_hostname }}\\n\" dest : /etc/motd notify : Set MOTD handlers : - name : Set MOTD debug : msg : The MOTD was set Tip By default Ansible matches the facts gathered by the setup module with the corresponding hosts. Looping over the hosts and referencing the gathered facts will yield host-specific values. Execute the following command ansible-playbook playbook.yml What is the expected result of the command Each host will have a different MOTD based on its inventory hostname.","title":"Example 1"},{"location":"training/extra/loops/01/#example-1","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all become : true tasks : - name : Set SSH message of the day (motd) copy : content : \"Working on: {{ ansible_hostname }}\\n\" dest : /etc/motd notify : Set MOTD handlers : - name : Set MOTD debug : msg : The MOTD was set Tip By default Ansible matches the facts gathered by the setup module with the corresponding hosts. Looping over the hosts and referencing the gathered facts will yield host-specific values. Execute the following command ansible-playbook playbook.yml What is the expected result of the command Each host will have a different MOTD based on its inventory hostname.","title":"Example 1"},{"location":"training/extra/loops/02/","text":"Example 1 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all become : true tasks : - name : Set SSH message of the day (motd) copy : content : \"Host system: {{ item }}\\n\" dest : /etc/motd notify : Set MOTD with_items : - CentOS - Ubuntu when : ansible_distribution == item handlers : - name : Set MOTD debug : msg : The MOTD was set Tip You can use the with_<lookup> loop syntax to iterate over different data types and perform more complex operations. Execute the following command ansible-playbook playbook.yml","title":"Example 2"},{"location":"training/extra/loops/02/#example-1","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all become : true tasks : - name : Set SSH message of the day (motd) copy : content : \"Host system: {{ item }}\\n\" dest : /etc/motd notify : Set MOTD with_items : - CentOS - Ubuntu when : ansible_distribution == item handlers : - name : Set MOTD debug : msg : The MOTD was set Tip You can use the with_<lookup> loop syntax to iterate over different data types and perform more complex operations. Execute the following command ansible-playbook playbook.yml","title":"Example 1"},{"location":"training/extra/loops/03/","text":"Example 1 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 become : true tasks : - name : Create multiple users user : name : \"{{ item.key }}\" comment : \"{{ item.value.comment }}\" with_dict : john : comment : This is John mary : comment : This is Mary Tip The with_dict loop is particularly useful and frequently used in Ansible Playbooks. Execute the following command ansible-playbook playbook.yml","title":"Example 3"},{"location":"training/extra/loops/03/#example-1","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 become : true tasks : - name : Create multiple users user : name : \"{{ item.key }}\" comment : \"{{ item.value.comment }}\" with_dict : john : comment : This is John mary : comment : This is Mary Tip The with_dict loop is particularly useful and frequently used in Ansible Playbooks. Execute the following command ansible-playbook playbook.yml","title":"Example 1"},{"location":"training/import-include-tags/01/","text":"Example 1 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' tasks.yml - name : Task2 debug : msg : This is Task2 - name : Task3 debug : msg : This is Task3 playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Task1 debug : msg : This is Task1 - include_tasks : tasks.yml Tip Tasks can be defined in seperate files and imported using the include_tasks directive. This is especially useful if we want to include a certain group of tasks conditionally. Execute the following command ansible-playbook playbook.yml","title":"Example 1"},{"location":"training/import-include-tags/01/#example-1","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' tasks.yml - name : Task2 debug : msg : This is Task2 - name : Task3 debug : msg : This is Task3 playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Task1 debug : msg : This is Task1 - include_tasks : tasks.yml Tip Tasks can be defined in seperate files and imported using the include_tasks directive. This is especially useful if we want to include a certain group of tasks conditionally. Execute the following command ansible-playbook playbook.yml","title":"Example 1"},{"location":"training/import-include-tags/02/","text":"Example 2 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' tasks.yml - name : Task2 debug : msg : This is Task2 - name : Task3 debug : msg : This is Task3 playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Task2 debug : msg : This is Task1 - import_tasks : tasks.yml Tip Tasks can also be imported with import_tasks . The main difference is that the import_* statements are pre-processed at the time the playbook is parsed, whereas include_* is parsed in runtime. Execute the following command ansible-playbook playbook.yml","title":"Example 2"},{"location":"training/import-include-tags/02/#example-2","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' tasks.yml - name : Task2 debug : msg : This is Task2 - name : Task3 debug : msg : This is Task3 playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Task2 debug : msg : This is Task1 - import_tasks : tasks.yml Tip Tasks can also be imported with import_tasks . The main difference is that the import_* statements are pre-processed at the time the playbook is parsed, whereas include_* is parsed in runtime. Execute the following command ansible-playbook playbook.yml","title":"Example 2"},{"location":"training/import-include-tags/03/","text":"Example 3 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' tasks_import.yml - name : Import1 debug : msg : Import1 - name : Set import_tasks_condition set_fact : import_tasks_condition : false - name : Import2 debug : msg : Import2 - name : Import3 debug : msg : Import3 tasks_include.yml - name : Include1 debug : msg : Include1 - name : Set include_tasks_condition set_fact : include_tasks_condition : false - name : Include2 debug : msg : Include2 - name : Include3 debug : msg : Include3 playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Include tasks run include_tasks : tasks_include.yml when : include_tasks_condition is not defined - name : Import tasks run import_tasks : tasks_import.yml when : import_tasks_condition is not defined Tip You can use facts to regulate the behavior of include_* and import_* statements. Execute the following command ansible-playbook playbook.yml What is the expected output of the command ? Since the import_* statements are pre-processed the execution should be skipped for Import 2 and Import 3 .","title":"Example 3"},{"location":"training/import-include-tags/03/#example-3","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' tasks_import.yml - name : Import1 debug : msg : Import1 - name : Set import_tasks_condition set_fact : import_tasks_condition : false - name : Import2 debug : msg : Import2 - name : Import3 debug : msg : Import3 tasks_include.yml - name : Include1 debug : msg : Include1 - name : Set include_tasks_condition set_fact : include_tasks_condition : false - name : Include2 debug : msg : Include2 - name : Include3 debug : msg : Include3 playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Include tasks run include_tasks : tasks_include.yml when : include_tasks_condition is not defined - name : Import tasks run import_tasks : tasks_import.yml when : import_tasks_condition is not defined Tip You can use facts to regulate the behavior of include_* and import_* statements. Execute the following command ansible-playbook playbook.yml What is the expected output of the command ? Since the import_* statements are pre-processed the execution should be skipped for Import 2 and Import 3 .","title":"Example 3"},{"location":"training/import-include-tags/04/","text":"Example 4 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' extra.yml - name : extra hosts : ubuntu1 gather_facts : false tasks : - name : Task2 debug : msg : Task2 in extra main.yml - name : main hosts : centos1 gather_facts : false tasks : - name : Task1 debug : msg : Task1 in main - import_playbook : extra.yml Tip The mechanisms of include_* and import_* are not limited to the tasks scope. The user can import/include whole playbooks or roles . Execute the following command ansible-playbook playbook.yml","title":"Example 4"},{"location":"training/import-include-tags/04/#example-4","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' extra.yml - name : extra hosts : ubuntu1 gather_facts : false tasks : - name : Task2 debug : msg : Task2 in extra main.yml - name : main hosts : centos1 gather_facts : false tasks : - name : Task1 debug : msg : Task1 in main - import_playbook : extra.yml Tip The mechanisms of include_* and import_* are not limited to the tasks scope. The user can import/include whole playbooks or roles . Execute the following command ansible-playbook playbook.yml","title":"Example 4"},{"location":"training/import-include-tags/05/","text":"Example 5 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Task1 debug : msg : This is Task1 tags : - task1 - name : Task2 debug : msg : This is Task2 tags : - task2 Tip Tags can be used to add additional grouping to tasks , playbooks and roles . Execute the following command ansible-playbook playbook.yml Bonus round Check the ansible-playbook CLI options and execute only tasks that contain the task1 tag exclude all tasks taht have the task1 tag","title":"Example 5"},{"location":"training/import-include-tags/05/#example-5","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Task1 debug : msg : This is Task1 tags : - task1 - name : Task2 debug : msg : This is Task2 tags : - task2 Tip Tags can be used to add additional grouping to tasks , playbooks and roles . Execute the following command ansible-playbook playbook.yml Bonus round Check the ansible-playbook CLI options and execute only tasks that contain the task1 tag exclude all tasks taht have the task1 tag","title":"Example 5"},{"location":"training/inventories-privileges/01/","text":"Example 1 hosts.ini [centos] provisioner ansible_connection = local centos1 ansible_host = 192.168.77.22 [ubuntu] ubuntu1 ansible_host = 192.168.77.23 Execute the whoami command on all hosts. ansible all -m command -a whoami Tip The default user used by the SSH client is the same as your current user on the provisioner. Add the --become or -b flag to the previous command. Notice the differences in the command's outputs. ansible all -m command -a whoami -b The --become directive instructs Ansible to take the identity of the superuser on the remote hosts. This feature requires on of the following options passwordless sudo access is enabled for the remote user the name and password of the associated superuser are passed to Ansible","title":"Example 1"},{"location":"training/inventories-privileges/01/#example-1","text":"hosts.ini [centos] provisioner ansible_connection = local centos1 ansible_host = 192.168.77.22 [ubuntu] ubuntu1 ansible_host = 192.168.77.23 Execute the whoami command on all hosts. ansible all -m command -a whoami Tip The default user used by the SSH client is the same as your current user on the provisioner. Add the --become or -b flag to the previous command. Notice the differences in the command's outputs. ansible all -m command -a whoami -b The --become directive instructs Ansible to take the identity of the superuser on the remote hosts. This feature requires on of the following options passwordless sudo access is enabled for the remote user the name and password of the associated superuser are passed to Ansible","title":"Example 1"},{"location":"training/inventories-privileges/02/","text":"Example 2 hosts.ini [centos] provisioner ansible_connection = local centos1 ansible_host = 192.168.77.22 ansible_user=root [ubuntu] ubuntu1 ansible_host = 192.168.77.23 ansible_become=true Tip Many variables including the become directive and the SSH user name can be specified as hostvars , which are simply put a group of variables that describe a single host. Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will generate a different output on every host on provisioner - we will be identified as the vagrant user since we did not explicitly instruct Ansible to act otherwise on centos1 - we will get an error since our SSH authentication method (public key) is valid only for the vagrant user on ubuntu1 - we will run the command as the root user since we instructed Ansible to use the become directive Bonus round Fix the problem with centos1 . Use one of the following methods or come up one with one on your own copy the provisioner's SSH public key to the authorized_keys of the root user on centos1 (when prompted for the root password type vagrant ) ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.77.22 modify the hosts.ini file by adding ansible_password=vagrant to the line describing centos1 . Before executing the command install the sshpass program on the provisioner. sudo yum install -y sshpass","title":"Example 2"},{"location":"training/inventories-privileges/02/#example-2","text":"hosts.ini [centos] provisioner ansible_connection = local centos1 ansible_host = 192.168.77.22 ansible_user=root [ubuntu] ubuntu1 ansible_host = 192.168.77.23 ansible_become=true Tip Many variables including the become directive and the SSH user name can be specified as hostvars , which are simply put a group of variables that describe a single host. Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will generate a different output on every host on provisioner - we will be identified as the vagrant user since we did not explicitly instruct Ansible to act otherwise on centos1 - we will get an error since our SSH authentication method (public key) is valid only for the vagrant user on ubuntu1 - we will run the command as the root user since we instructed Ansible to use the become directive Bonus round Fix the problem with centos1 . Use one of the following methods or come up one with one on your own copy the provisioner's SSH public key to the authorized_keys of the root user on centos1 (when prompted for the root password type vagrant ) ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.77.22 modify the hosts.ini file by adding ansible_password=vagrant to the line describing centos1 . Before executing the command install the sshpass program on the provisioner. sudo yum install -y sshpass","title":"Example 2"},{"location":"training/inventories-privileges/03/","text":"Example 3 hosts.ini [centos] provisioner ansible_connection = local centos1 ansible_host = 192.168.77.22 ansible_become=true ansible_become_method=su [ubuntu] ubuntu1 ansible_host = 192.168.77.23 ansible_become=true ansible_become_method=sudo Tip You can change the behavior of the become directive by editing the default become_method (which is sudo ). Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will generate a different output on every host on provisioner - we will be identified as the vagrant user since we did not explicitly instruct Ansible to act otherwise on centos1 - we will receive a timeout since we have not provided any credentials for the su prompt on ubuntu1 - we will run the command as the root user since we instructed Ansible to use sudo , which as we have already established is passwordless Bonus round Fix the problem with centos1 . Use one of the following methods instruct Ansible to ask for password in runtime using the --ask-become-pass ( -K ) flag ansible all -m command -a \"whoami\" -K modify the hosts.ini file by adding ansible_become_pass=vagrant to the line describing centos1","title":"Example 3"},{"location":"training/inventories-privileges/03/#example-3","text":"hosts.ini [centos] provisioner ansible_connection = local centos1 ansible_host = 192.168.77.22 ansible_become=true ansible_become_method=su [ubuntu] ubuntu1 ansible_host = 192.168.77.23 ansible_become=true ansible_become_method=sudo Tip You can change the behavior of the become directive by editing the default become_method (which is sudo ). Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will generate a different output on every host on provisioner - we will be identified as the vagrant user since we did not explicitly instruct Ansible to act otherwise on centos1 - we will receive a timeout since we have not provided any credentials for the su prompt on ubuntu1 - we will run the command as the root user since we instructed Ansible to use sudo , which as we have already established is passwordless Bonus round Fix the problem with centos1 . Use one of the following methods instruct Ansible to ask for password in runtime using the --ask-become-pass ( -K ) flag ansible all -m command -a \"whoami\" -K modify the hosts.ini file by adding ansible_become_pass=vagrant to the line describing centos1","title":"Example 3"},{"location":"training/inventories-privileges/04/","text":"Example 4 hosts.ini [centos] priovsioner ansible_connection = local centos1 ansible_host = 192.168.77.22 ansible_port=2345 [ubuntu] ubuntu1 ansible_host = 192.168.77.23 Tip You can desribe your hosts with various parameters (eg. ansible_port , which defines the port number on which the SSH server on the remote listens for connections). For a comprehensive list take look at the official documentation . Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will fail for centos1 since by default the SSH server listens on port 22. Bonus round Fix the problem with centos1 by executing the following steps open a SSH connection to centos1 ssh vagrant@192.168.77.22 edit the SSH server configuration on the remote sudo vi /etc/sshd/sshd_config uncomment the line starting with #Port , set the port value to 2345 (the resulting line should read Port 2345 ) and save the changes update the SELinux policy on the remote (you will need to install the policycoreutils-python package) sudo yum install -y policycoreutils-python sudo semanage port -a -t ssh_port_t -p tcp 2345 restart the sshd service sudo systemctl restart sshd","title":"Example 4"},{"location":"training/inventories-privileges/04/#example-4","text":"hosts.ini [centos] priovsioner ansible_connection = local centos1 ansible_host = 192.168.77.22 ansible_port=2345 [ubuntu] ubuntu1 ansible_host = 192.168.77.23 Tip You can desribe your hosts with various parameters (eg. ansible_port , which defines the port number on which the SSH server on the remote listens for connections). For a comprehensive list take look at the official documentation . Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will fail for centos1 since by default the SSH server listens on port 22. Bonus round Fix the problem with centos1 by executing the following steps open a SSH connection to centos1 ssh vagrant@192.168.77.22 edit the SSH server configuration on the remote sudo vi /etc/sshd/sshd_config uncomment the line starting with #Port , set the port value to 2345 (the resulting line should read Port 2345 ) and save the changes update the SELinux policy on the remote (you will need to install the policycoreutils-python package) sudo yum install -y policycoreutils-python sudo semanage port -a -t ssh_port_t -p tcp 2345 restart the sshd service sudo systemctl restart sshd","title":"Example 4"},{"location":"training/inventories-privileges/05/","text":"Example 5 hosts.ini [centos] centos1 ansible_connection = local centos2 ansible_host = 192.168.77.22 ansible_port=2345 centos[1:2] ansible_become = true [ubuntu] ubuntu1 ansible_host = 192.168.77.23 Tip You can define common variables for a range of remote hosts with the same base name by using the [start:end] notation. Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will be run as the root user for all hosts that have their names start with centos , followed by a number in range from 1 to 2.","title":"Example 5"},{"location":"training/inventories-privileges/05/#example-5","text":"hosts.ini [centos] centos1 ansible_connection = local centos2 ansible_host = 192.168.77.22 ansible_port=2345 centos[1:2] ansible_become = true [ubuntu] ubuntu1 ansible_host = 192.168.77.23 Tip You can define common variables for a range of remote hosts with the same base name by using the [start:end] notation. Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will be run as the root user for all hosts that have their names start with centos , followed by a number in range from 1 to 2.","title":"Example 5"},{"location":"training/inventories-privileges/06/","text":"Example 6 hosts.ini [centos] provisioner ansible_connection = local centos2 ansible_host = 192.168.77.22 ansible_port=2345 [ubuntu] ubuntu1 ansible_host = 192.168.77.23 [centos:vars] ansible_become = true Tip Apart from defining hostvars , which describe only a single host, we can incorporate groupvars that gather common variables for all remote hosts that belong to the same group. Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will be run as the root user for all hosts that belong to the centos group.","title":"Example 6"},{"location":"training/inventories-privileges/06/#example-6","text":"hosts.ini [centos] provisioner ansible_connection = local centos2 ansible_host = 192.168.77.22 ansible_port=2345 [ubuntu] ubuntu1 ansible_host = 192.168.77.23 [centos:vars] ansible_become = true Tip Apart from defining hostvars , which describe only a single host, we can incorporate groupvars that gather common variables for all remote hosts that belong to the same group. Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will be run as the root user for all hosts that belong to the centos group.","title":"Example 6"},{"location":"training/inventories-privileges/07/","text":"Example 7 hosts.ini [centos] provisioner ansible_connection = local centos2 ansible_host = 192.168.77.22 ansible_port=2345 [ubuntu] ubuntu1 ansible_host = 192.168.77.23 [linux:children] centos ubuntu [linux:vars] ansible_become = true Tip You can use the children notation to incorporate property inheritance in your invetories in order to desribe more complex systems. Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will be run as the root user for all hosts since the centos and ubuntu groups are children of the linux group.","title":"Example 7"},{"location":"training/inventories-privileges/07/#example-7","text":"hosts.ini [centos] provisioner ansible_connection = local centos2 ansible_host = 192.168.77.22 ansible_port=2345 [ubuntu] ubuntu1 ansible_host = 192.168.77.23 [linux:children] centos ubuntu [linux:vars] ansible_become = true Tip You can use the children notation to incorporate property inheritance in your invetories in order to desribe more complex systems. Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" What is the expected output of the command ? The command will be run as the root user for all hosts since the centos and ubuntu groups are children of the linux group.","title":"Example 7"},{"location":"training/inventories-privileges/08/","text":"Example 8 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' linux : children : centos : ubuntu : vars : ansible_become : true Tip The YAML file format is currently the most popular solution for building Ansible inventories, although the default inventory format is JSON . Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" Add ansible_become: false to the description of centos1 (indentation should match ansible_port and ansible_host ) and run the command again. What is the expected output of the command ? The command will be run as the root user for all hosts except centos1 . This example illustrates that hostvars take precedence over groupvars .","title":"Example 8"},{"location":"training/inventories-privileges/08/#example-8","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' linux : children : centos : ubuntu : vars : ansible_become : true Tip The YAML file format is currently the most popular solution for building Ansible inventories, although the default inventory format is JSON . Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" Add ansible_become: false to the description of centos1 (indentation should match ansible_port and ansible_host ) and run the command again. What is the expected output of the command ? The command will be run as the root user for all hosts except centos1 . This example illustrates that hostvars take precedence over groupvars .","title":"Example 8"},{"location":"training/inventories-privileges/09/","text":"Example 9 hosts.json { \"centos\" : { \"hosts\" : { \"provisioner\" : { \"ansible_connection\" : \"local\" }, \"centos2\" : { \"ansible_host\" : \"192.168.77.22\" , \"ansible_port\" : 2345 } }, \"vars\" : { \"ansible_become\" : true } }, \"ubuntu\" : { \"hosts\" : { \"ubuntu1\" : { \"ansible_host\" : \"192.168.77.23\" } } } } Tip The JSON representation of an inventory can become useful when obtained from an external REST API. Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" Bonus round Try to reproduce the YAML inventory from the previous example using the JSON syntax. Since all keys must have corresponding values in JSON , use null for keys that were empty. For bigger inventories you could automate this process eg. with a simple Python script. import yaml import json with open ( 'hosts.yml' , 'r' ) as inv : data = yaml . full_load ( inv ) with open ( 'hosts.json' , 'w' ) as out : json . dump ( data , out , indent = 4 )","title":"Example 9"},{"location":"training/inventories-privileges/09/#example-9","text":"hosts.json { \"centos\" : { \"hosts\" : { \"provisioner\" : { \"ansible_connection\" : \"local\" }, \"centos2\" : { \"ansible_host\" : \"192.168.77.22\" , \"ansible_port\" : 2345 } }, \"vars\" : { \"ansible_become\" : true } }, \"ubuntu\" : { \"hosts\" : { \"ubuntu1\" : { \"ansible_host\" : \"192.168.77.23\" } } } } Tip The JSON representation of an inventory can become useful when obtained from an external REST API. Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" Bonus round Try to reproduce the YAML inventory from the previous example using the JSON syntax. Since all keys must have corresponding values in JSON , use null for keys that were empty. For bigger inventories you could automate this process eg. with a simple Python script. import yaml import json with open ( 'hosts.yml' , 'r' ) as inv : data = yaml . full_load ( inv ) with open ( 'hosts.json' , 'w' ) as out : json . dump ( data , out , indent = 4 )","title":"Example 9"},{"location":"training/inventories-privileges/10/","text":"Example 10 hosts.py #!/bin/env python import json import argparse class SampleInventory : HOSTS = [ { \"host\" : \"provisioner\" , \"vars\" : { 'ansible_connection' : 'local' } }, { \"host\" : \"centos1\" , \"vars\" : { \"ansible_host\" : \"192.168.77.22\" , \"ansible_port\" : 2345 } }, { \"host\" : \"ubuntu1\" , \"vars\" : { \"ansible_host\" : \"192.168.77.23\" } } ] GROUPS = [ { \"name\" : \"centos\" , \"hosts\" : [ \"provisioner\" , \"centos1\" ], \"vars\" : { \"ansible_become\" : True } }, { \"name\" : \"ubuntu\" , \"hosts\" : [ \"ubuntu1\" ] } ] def generate_response ( self , parser ): args = parser . parse_args () if args . list and args . host is None : self . get_list () elif not args . list and args . host : self . get_host ( args . host ) else : parser . print_help () def get_host ( self , host ): try : host_data = [ x for x in self . HOSTS if x [ \"host\" ] == host ][ 0 ] print ( json . dumps ( host_data [ \"vars\" ], indent = 4 )) except IndexError as e : raise IndexError ( 'Host not found.' ) def get_list ( self ): inventory = {} meta = self . create_meta () groups = self . create_groups () inventory . update ( meta ) inventory . update ( groups ) print ( json . dumps ( inventory , indent = 4 )) def create_meta ( self ): meta = { \"_meta\" : { \"hostvars\" : {} } } for host in self . HOSTS : all_vars = {} host_hostvars = host [ \"vars\" ] host_groupvars = self . get_host_groupvars ( host ) all_vars . update ( host_hostvars ) all_vars . update ( host_groupvars ) meta [ \"_meta\" ][ \"hostvars\" ][ host [ \"host\" ]] = all_vars return meta def get_host_groupvars ( self , host ): group_vars = {} for group in self . GROUPS : if host [ \"host\" ] in group [ \"hosts\" ]: try : group_vars . update ( group [ \"vars\" ]) except KeyError : pass return group_vars def create_groups ( self ): groups = { \"all\" : { \"children\" : [ \"ungrouped\" ] } } for group in self . GROUPS : groups [ group [ \"name\" ]] = group [ \"hosts\" ] groups [ \"all\" ][ \"children\" ] . append ( group [ \"name\" ]) return groups if __name__ == '__main__' : parser = argparse . ArgumentParser () parser . add_argument ( '--list' , action = 'store_true' ) parser . add_argument ( '--host' ) SampleInventory () . generate_response ( parser ) Tip Dynamic inventories can be extremely useful especially when you want to create an inventory from another file (eg. Terraform output). They can be written in any programming language provided that they are executables that generate the correct ouput and accept the --list flag. Compare the outputs of the following commands python hosts.py --list ansible-inventory --list Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" Bonus round Create a Bash script that will act as an Ansible inventory. Use the output of ansible-inventory --list to hardcode the data or call hosts.py from within the script.","title":"Example 10"},{"location":"training/inventories-privileges/10/#example-10","text":"hosts.py #!/bin/env python import json import argparse class SampleInventory : HOSTS = [ { \"host\" : \"provisioner\" , \"vars\" : { 'ansible_connection' : 'local' } }, { \"host\" : \"centos1\" , \"vars\" : { \"ansible_host\" : \"192.168.77.22\" , \"ansible_port\" : 2345 } }, { \"host\" : \"ubuntu1\" , \"vars\" : { \"ansible_host\" : \"192.168.77.23\" } } ] GROUPS = [ { \"name\" : \"centos\" , \"hosts\" : [ \"provisioner\" , \"centos1\" ], \"vars\" : { \"ansible_become\" : True } }, { \"name\" : \"ubuntu\" , \"hosts\" : [ \"ubuntu1\" ] } ] def generate_response ( self , parser ): args = parser . parse_args () if args . list and args . host is None : self . get_list () elif not args . list and args . host : self . get_host ( args . host ) else : parser . print_help () def get_host ( self , host ): try : host_data = [ x for x in self . HOSTS if x [ \"host\" ] == host ][ 0 ] print ( json . dumps ( host_data [ \"vars\" ], indent = 4 )) except IndexError as e : raise IndexError ( 'Host not found.' ) def get_list ( self ): inventory = {} meta = self . create_meta () groups = self . create_groups () inventory . update ( meta ) inventory . update ( groups ) print ( json . dumps ( inventory , indent = 4 )) def create_meta ( self ): meta = { \"_meta\" : { \"hostvars\" : {} } } for host in self . HOSTS : all_vars = {} host_hostvars = host [ \"vars\" ] host_groupvars = self . get_host_groupvars ( host ) all_vars . update ( host_hostvars ) all_vars . update ( host_groupvars ) meta [ \"_meta\" ][ \"hostvars\" ][ host [ \"host\" ]] = all_vars return meta def get_host_groupvars ( self , host ): group_vars = {} for group in self . GROUPS : if host [ \"host\" ] in group [ \"hosts\" ]: try : group_vars . update ( group [ \"vars\" ]) except KeyError : pass return group_vars def create_groups ( self ): groups = { \"all\" : { \"children\" : [ \"ungrouped\" ] } } for group in self . GROUPS : groups [ group [ \"name\" ]] = group [ \"hosts\" ] groups [ \"all\" ][ \"children\" ] . append ( group [ \"name\" ]) return groups if __name__ == '__main__' : parser = argparse . ArgumentParser () parser . add_argument ( '--list' , action = 'store_true' ) parser . add_argument ( '--host' ) SampleInventory () . generate_response ( parser ) Tip Dynamic inventories can be extremely useful especially when you want to create an inventory from another file (eg. Terraform output). They can be written in any programming language provided that they are executables that generate the correct ouput and accept the --list flag. Compare the outputs of the following commands python hosts.py --list ansible-inventory --list Try to execute the whoami command on all hosts. ansible all -m command -a \"whoami\" Bonus round Create a Bash script that will act as an Ansible inventory. Use the output of ansible-inventory --list to hardcode the data or call hosts.py from within the script.","title":"Example 10"},{"location":"training/modules/01/","text":"Example 1 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' Tip The setup module is at the core of Ansible. It gathers basic information about the remote hosts. By default it is always run at the beginning of each playbook. Check out the module's official documentation or run ansible-doc setup Execute the following command and look for the Linux distribution name on the remote host ansible centos1 -m setup What is the expected output of the command? We expect the distribution to be set to CentOS . Bonus round Filter out the name of network interface on the remote host where the default IPv4 address is located. In order to complete the task install jq on your system sudo yum install -y jq parse the setup module's output to make it a valid JSON (you can pipe the result of the Ansible command to sed '1c {' ) use jq to find the corresponding key-pair value in the output (take a look at this tutorial to get a basic idea on how jq works). The key you are loooking for is under ansible_facts -> ansible_default_ipv4 -> interface .","title":"Example 1"},{"location":"training/modules/01/#example-1","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' Tip The setup module is at the core of Ansible. It gathers basic information about the remote hosts. By default it is always run at the beginning of each playbook. Check out the module's official documentation or run ansible-doc setup Execute the following command and look for the Linux distribution name on the remote host ansible centos1 -m setup What is the expected output of the command? We expect the distribution to be set to CentOS . Bonus round Filter out the name of network interface on the remote host where the default IPv4 address is located. In order to complete the task install jq on your system sudo yum install -y jq parse the setup module's output to make it a valid JSON (you can pipe the result of the Ansible command to sed '1c {' ) use jq to find the corresponding key-pair value in the output (take a look at this tutorial to get a basic idea on how jq works). The key you are loooking for is under ansible_facts -> ansible_default_ipv4 -> interface .","title":"Example 1"},{"location":"training/modules/02/","text":"Example 1 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' Tip The file module is widely used alongside the copy and template modules for performing operations on files, symlinks and directories. Check out the module's official documentation or run ansible-doc file Execute the following command ansible centos1 -m file -a 'path=\"/etc/foo.conf\" state=touch' What is the expected output of the command? The command should fail (with Permission denied ) as the vagrant user does not have write permissions inside the /etc directory. Bonus round Using your knowledge of privilege escalation in Ansible propose a solution that would make the file creation possible.","title":"Example 2"},{"location":"training/modules/02/#example-1","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' Tip The file module is widely used alongside the copy and template modules for performing operations on files, symlinks and directories. Check out the module's official documentation or run ansible-doc file Execute the following command ansible centos1 -m file -a 'path=\"/etc/foo.conf\" state=touch' What is the expected output of the command? The command should fail (with Permission denied ) as the vagrant user does not have write permissions inside the /etc directory. Bonus round Using your knowledge of privilege escalation in Ansible propose a solution that would make the file creation possible.","title":"Example 1"},{"location":"training/modules/03/","text":"Example 3 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' Tip The copy module enables the user to copy files from the provisioner to the remotes. Check out the module's official documentation or run ansible-doc copy Create an empty file and copy it to the remote hosts home directories touch test.txt ansible all -m copy -a 'src=\"test.txt\" dest=\"/home/vagrant/\"' Bonus round Create a message of the day (MOTD) for the SSH server on centos1 . The contents of the message should be located in /etc/motd .","title":"Example 3"},{"location":"training/modules/03/#example-3","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' Tip The copy module enables the user to copy files from the provisioner to the remotes. Check out the module's official documentation or run ansible-doc copy Create an empty file and copy it to the remote hosts home directories touch test.txt ansible all -m copy -a 'src=\"test.txt\" dest=\"/home/vagrant/\"' Bonus round Create a message of the day (MOTD) for the SSH server on centos1 . The contents of the message should be located in /etc/motd .","title":"Example 3"},{"location":"training/modules/04/","text":"Example 4 hosts.yml centos : hosts : provisioner : ansible_connection : local unique_hash : \"NDRhOTBlZmU3OTc2\" centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 unique_hash : \"MzI0ZTU2ZWMxNTkz\" ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' unique_hash : \"YjlkYTdlMjYyYTU3\" Tip The template module enables the user to use Jinja2 templates and copy them to the remote hosts. It is very useful when copying multiple configuration files that depend on a set of variables. Check out the module's official documentation or run ansible-doc template Execute the following command echo \"{{ unique_hash }}\" > hash.j2 ansible all -m template -a 'src=\"hash.j2\" dest=\"/home/vagrant/.unique\"' Bonus round Knowing that the variable inventory_hostname stores the host's name as described in Ansible's inventory, change the MOTD on centos1 to read Hello from centos1! .","title":"Example 4"},{"location":"training/modules/04/#example-4","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local unique_hash : \"NDRhOTBlZmU3OTc2\" centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 unique_hash : \"MzI0ZTU2ZWMxNTkz\" ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' unique_hash : \"YjlkYTdlMjYyYTU3\" Tip The template module enables the user to use Jinja2 templates and copy them to the remote hosts. It is very useful when copying multiple configuration files that depend on a set of variables. Check out the module's official documentation or run ansible-doc template Execute the following command echo \"{{ unique_hash }}\" > hash.j2 ansible all -m template -a 'src=\"hash.j2\" dest=\"/home/vagrant/.unique\"' Bonus round Knowing that the variable inventory_hostname stores the host's name as described in Ansible's inventory, change the MOTD on centos1 to read Hello from centos1! .","title":"Example 4"},{"location":"training/modules/05/","text":"Example 5 hosts.yml centos : hosts : provisioner : ansible_connection : local unique_hash : \"NDRhOTBlZmU3OTc2\" centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 unique_hash : \"MzI0ZTU2ZWMxNTkz\" ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' unique_hash : \"YjlkYTdlMjYyYTU3\" Tip The lineinfile module enables the user change single lines in a file on the remote. It is frequently used to change values in configuration files. Check out the module's official documentation or run ansible-doc lineinfile Create a Jinja2 template and copy it to the remote hosts ansible centos1 -m lineinfile -a 'path=\"/etc/motd\" state=\"present\" line=\"Have a nice day\"' -b Bonus round Use your current knowledge of Ansible modules to revert the changes introduced in Example 4 of Section 1. Inventories and privileges escalation (change the SSH server listening port on centos1 back to 22). you will need to remove the Port 2345 entry from /etc/ssh/sshd_config you will need to run sudo semanage port -d -t ssh_port_t -p tcp 2345 you will need to restart the SSH server; use Ansible's systemd module","title":"Example 5"},{"location":"training/modules/05/#example-5","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local unique_hash : \"NDRhOTBlZmU3OTc2\" centos1 : ansible_host : '192.168.77.22' ansible_port : 2345 unique_hash : \"MzI0ZTU2ZWMxNTkz\" ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' unique_hash : \"YjlkYTdlMjYyYTU3\" Tip The lineinfile module enables the user change single lines in a file on the remote. It is frequently used to change values in configuration files. Check out the module's official documentation or run ansible-doc lineinfile Create a Jinja2 template and copy it to the remote hosts ansible centos1 -m lineinfile -a 'path=\"/etc/motd\" state=\"present\" line=\"Have a nice day\"' -b Bonus round Use your current knowledge of Ansible modules to revert the changes introduced in Example 4 of Section 1. Inventories and privileges escalation (change the SSH server listening port on centos1 back to 22). you will need to remove the Port 2345 entry from /etc/ssh/sshd_config you will need to run sudo semanage port -d -t ssh_port_t -p tcp 2345 you will need to restart the SSH server; use Ansible's systemd module","title":"Example 5"},{"location":"training/playbooks/01/","text":"Example 1 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all tasks : - name : Example task command : whoami Tip Ansible Playbook's are used to gather multiple consecutive task executions. The tasks can be run synchronously, in parallel, in batches or match conditional clauses. Execute the following command ansible-playbook playbook.yml Which modules will be run during this playbook execution? This playbook execution will launch the setup and command modules on the remote hosts. The [Gathering Facts] section in ansible-playbook log corresponds to the execution of the setup module. Bonus round Using the debug module catch the ansible_distribution for each host.","title":"Example 1"},{"location":"training/playbooks/01/#example-1","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all tasks : - name : Example task command : whoami Tip Ansible Playbook's are used to gather multiple consecutive task executions. The tasks can be run synchronously, in parallel, in batches or match conditional clauses. Execute the following command ansible-playbook playbook.yml Which modules will be run during this playbook execution? This playbook execution will launch the setup and command modules on the remote hosts. The [Gathering Facts] section in ansible-playbook log corresponds to the execution of the setup module. Bonus round Using the debug module catch the ansible_distribution for each host.","title":"Example 1"},{"location":"training/playbooks/02/","text":"Example 2 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all gather_facts : false tasks : - name : Example task command : whoami Tip The setup module can generate large compuational costs when running against multiple remote hosts. In that case we can disable this functionality by adding the gather_facts: false directive to our playbook. Execute the following command ansible-playbook playbook.yml Notice that the [Gathering Facts] section is missing from the log.","title":"Example 2"},{"location":"training/playbooks/02/#example-2","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all gather_facts : false tasks : - name : Example task command : whoami Tip The setup module can generate large compuational costs when running against multiple remote hosts. In that case we can disable this functionality by adding the gather_facts: false directive to our playbook. Execute the following command ansible-playbook playbook.yml Notice that the [Gathering Facts] section is missing from the log.","title":"Example 2"},{"location":"training/playbooks/03/","text":"Example 3 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all gather_facts : false tasks : - name : Example task command : whoami register : whoami_output - debug : msg : \"Remote user: {{ whoami_output.stdout }}\" Tip The debug module can be used to output the results of remote commands. The register directive creates a new variable in the playbook's scope, which can be accessed by other tasks. Execute the following command ansible-playbook playbook.yml Bonus round Execute the same command while adding the -b flag. Notice the difference in the command's output.","title":"Example 3"},{"location":"training/playbooks/03/#example-3","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all gather_facts : false tasks : - name : Example task command : whoami register : whoami_output - debug : msg : \"Remote user: {{ whoami_output.stdout }}\" Tip The debug module can be used to output the results of remote commands. The register directive creates a new variable in the playbook's scope, which can be accessed by other tasks. Execute the following command ansible-playbook playbook.yml Bonus round Execute the same command while adding the -b flag. Notice the difference in the command's output.","title":"Example 3"},{"location":"training/playbooks/04/","text":"Example 4 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all become : true gather_facts : false tasks : - name : Example task command : whoami register : whoami_output - debug : msg : \"Remote user: {{ whoami_output.stdout }}\" Tip Privilage escalation in playbooks can be perfomed by adding the become: true directive. Execute the following command ansible-playbook playbook.yml","title":"Example 4"},{"location":"training/playbooks/04/#example-4","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all become : true gather_facts : false tasks : - name : Example task command : whoami register : whoami_output - debug : msg : \"Remote user: {{ whoami_output.stdout }}\" Tip Privilage escalation in playbooks can be perfomed by adding the become: true directive. Execute the following command ansible-playbook playbook.yml","title":"Example 4"},{"location":"training/playbooks/05/","text":"Example 6 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all gather_facts : false tasks : - name : Example task command : whoami notify : whoami_handler handlers : - name : whoami_handler debug : msg : \"Whoami was called on {{ inventory_hostname }}\" Tip Handlers are special tasks, which are always run at the end of a playbook. They are called by the notify directive. They are often used to perform post-installation modifications eg. starting of services, editing configuration files. Execute the following command ansible-playbook playbook.yml","title":"Example 5"},{"location":"training/playbooks/05/#example-6","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all gather_facts : false tasks : - name : Example task command : whoami notify : whoami_handler handlers : - name : whoami_handler debug : msg : \"Whoami was called on {{ inventory_hostname }}\" Tip Handlers are special tasks, which are always run at the end of a playbook. They are called by the notify directive. They are often used to perform post-installation modifications eg. starting of services, editing configuration files. Execute the following command ansible-playbook playbook.yml","title":"Example 6"},{"location":"training/playbooks/06/","text":"Example 7 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all become : true tasks : - name : Install vim on CentOS machines yum : name : vim state : present when : ansible_distribution == \"CentOS\" Tip Ansible Playbooks support conditional clauses. The when directive stores the conditions in string or list form. Execute the following command ansible-playbook playbook.yml What is the expected output of the command? The changes will take place on provisioner and centos1 , whereas ubuntu1 will get skipped since it does not match the conditional clause.","title":"Example 6"},{"location":"training/playbooks/06/#example-7","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all become : true tasks : - name : Install vim on CentOS machines yum : name : vim state : present when : ansible_distribution == \"CentOS\" Tip Ansible Playbooks support conditional clauses. The when directive stores the conditions in string or list form. Execute the following command ansible-playbook playbook.yml What is the expected output of the command? The changes will take place on provisioner and centos1 , whereas ubuntu1 will get skipped since it does not match the conditional clause.","title":"Example 7"},{"location":"training/playbooks/07/","text":"Example 8 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all become : true tasks : - name : Install vim on Ubuntu machines apt : name : vim state : present when : ansible_distribution == \"Ubuntu\" Tip Avoid using the command module for package installation, changes in systemd and other operations that can be automated using other Ansible modules. Execute the following command ansible-playbook playbook.yml Bonus round Create an Ansible Playbook that will install the Nginx web server on all machines (except provisioner ). The package that provides the package is called nginx on both distributions. use the apt or yum modules to download the package on CentOS host you will need to install the epel-release package before installing Nginx on Ubuntu hosts you will have to introduce changes to ufw (Ubuntu's firewall) - use the ufw module to allow a rule named Nginx HTTP use the systemd module to start the Nginx webserver on all hosts use curl from command line (outside of the playbook) or your web browser to check if the installation process was successfull","title":"Example 7"},{"location":"training/playbooks/07/#example-8","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all become : true tasks : - name : Install vim on Ubuntu machines apt : name : vim state : present when : ansible_distribution == \"Ubuntu\" Tip Avoid using the command module for package installation, changes in systemd and other operations that can be automated using other Ansible modules. Execute the following command ansible-playbook playbook.yml Bonus round Create an Ansible Playbook that will install the Nginx web server on all machines (except provisioner ). The package that provides the package is called nginx on both distributions. use the apt or yum modules to download the package on CentOS host you will need to install the epel-release package before installing Nginx on Ubuntu hosts you will have to introduce changes to ufw (Ubuntu's firewall) - use the ufw module to allow a rule named Nginx HTTP use the systemd module to start the Nginx webserver on all hosts use curl from command line (outside of the playbook) or your web browser to check if the installation process was successfull","title":"Example 8"},{"location":"training/variables-facts/01/","text":"Example 1 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all gather_facts : false vars : var1 : var1_value tasks : - debug : msg : \"This is the value of var1: {{ var1 }}\" Tip Variables can be defined in the playbook's scope by using the vars directive. Execute the following command ansible-playbook playbook.yml","title":"Example 1"},{"location":"training/variables-facts/01/#example-1","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : all gather_facts : false vars : var1 : var1_value tasks : - debug : msg : \"This is the value of var1: {{ var1 }}\" Tip Variables can be defined in the playbook's scope by using the vars directive. Execute the following command ansible-playbook playbook.yml","title":"Example 1"},{"location":"training/variables-facts/02/","text":"Example 2 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars : dict1 : key1 : value1 key2 : value2 tasks : - name : This is a dictionary debug : msg : \"{{ dict1 }}\" - name : Accessing the value using the Python syntax debug : msg : \"{{ dict1['key1'] }}\" - name : Accessing the value using the dot notation debug : msg : \"{{ dict1.key1 }}\" Tip Variables that represent dict type objects can be accessed using the dot notation or Python syntax by specifying the key value. Execute the following command ansible-playbook playbook.yml","title":"Example 2"},{"location":"training/variables-facts/02/#example-2","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars : dict1 : key1 : value1 key2 : value2 tasks : - name : This is a dictionary debug : msg : \"{{ dict1 }}\" - name : Accessing the value using the Python syntax debug : msg : \"{{ dict1['key1'] }}\" - name : Accessing the value using the dot notation debug : msg : \"{{ dict1.key1 }}\" Tip Variables that represent dict type objects can be accessed using the dot notation or Python syntax by specifying the key value. Execute the following command ansible-playbook playbook.yml","title":"Example 2"},{"location":"training/variables-facts/03/","text":"Example 3 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars : list1 : - value1 - value2 - value3 tasks : - name : This is a list debug : msg : \"{{ list1 }}\" - name : Accessing the values using the Python syntax debug : msg : \"{{ list1[0] }}\" - name : Accessing the values using the dot notation debug : msg : \"{{ list1.0 }}\" Tip Variables that represent list type objects can be accessed using the dot notation or Python syntax by specifying the index value. Execute the following command ansible-playbook playbook.yml","title":"Example 3"},{"location":"training/variables-facts/03/#example-3","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars : list1 : - value1 - value2 - value3 tasks : - name : This is a list debug : msg : \"{{ list1 }}\" - name : Accessing the values using the Python syntax debug : msg : \"{{ list1[0] }}\" - name : Accessing the values using the dot notation debug : msg : \"{{ list1.0 }}\" Tip Variables that represent list type objects can be accessed using the dot notation or Python syntax by specifying the index value. Execute the following command ansible-playbook playbook.yml","title":"Example 3"},{"location":"training/variables-facts/04/","text":"Example 4 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars : dict1_alternate : { key1 : value1 , key2 : value2 } tasks : - name : This is an inline dictionary debug : msg : \"{{ dict1_alternate }}\" - name : Accessing the value using the Python syntax debug : msg : \"{{ dict1_alternate['key1'] }}\" - name : Accessing the value using the dot notation debug : msg : \"{{ dict1_alternate.key1 }}\" Tip Dict type variables can also be represented in an alternate fashion. Execute the following command ansible-playbook playbook.yml","title":"Example 4"},{"location":"training/variables-facts/04/#example-4","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars : dict1_alternate : { key1 : value1 , key2 : value2 } tasks : - name : This is an inline dictionary debug : msg : \"{{ dict1_alternate }}\" - name : Accessing the value using the Python syntax debug : msg : \"{{ dict1_alternate['key1'] }}\" - name : Accessing the value using the dot notation debug : msg : \"{{ dict1_alternate.key1 }}\" Tip Dict type variables can also be represented in an alternate fashion. Execute the following command ansible-playbook playbook.yml","title":"Example 4"},{"location":"training/variables-facts/05/","text":"Example 5 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars : list1_alternate : [ value1 , value2 , value3 ] tasks : - name : This is a list debug : msg : \"{{ list1_alternate }}\" - name : Accessing the values using the Python syntax debug : msg : \"{{ list1_alternate[0] }}\" - name : Accessing the values using the dot notation debug : msg : \"{{ list1_alternate.0 }}\" Tip List type variables can also be represented in an alternate fashion. Execute the following command ansible-playbook playbook.yml","title":"Example 5"},{"location":"training/variables-facts/05/#example-5","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars : list1_alternate : [ value1 , value2 , value3 ] tasks : - name : This is a list debug : msg : \"{{ list1_alternate }}\" - name : Accessing the values using the Python syntax debug : msg : \"{{ list1_alternate[0] }}\" - name : Accessing the values using the dot notation debug : msg : \"{{ list1_alternate.0 }}\" Tip List type variables can also be represented in an alternate fashion. Execute the following command ansible-playbook playbook.yml","title":"Example 5"},{"location":"training/variables-facts/06/","text":"Example 6 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' bucket.yml list1 : - value1 - value2 - value3 list1_alternate : [ value1 , value2 , value3 ] dict1 : key1 : value1 dict1_alternate : { key1 : value1 } var1 : var1_value playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars_files : - bucket.yml tasks : - name : An external list debug : msg : \"{{ list1[0] }}\" - name : An external inline list debug : msg : \"{{ list1_alternate[0] }}\" - name : An external dictionary debug : msg : \"{{ dict1.key1 }}\" - name : An external inline dictionary debug : msg : \"{{ dict1_alternate['key1'] }}\" - name : An external variable debug : msg : \"{{ var1 }}\" Tip The vars_file directive can be used to load a set of variables from an existing YAML file. Execute the following command ansible-playbook playbook.yml","title":"Example 6"},{"location":"training/variables-facts/06/#example-6","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' bucket.yml list1 : - value1 - value2 - value3 list1_alternate : [ value1 , value2 , value3 ] dict1 : key1 : value1 dict1_alternate : { key1 : value1 } var1 : var1_value playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars_files : - bucket.yml tasks : - name : An external list debug : msg : \"{{ list1[0] }}\" - name : An external inline list debug : msg : \"{{ list1_alternate[0] }}\" - name : An external dictionary debug : msg : \"{{ dict1.key1 }}\" - name : An external inline dictionary debug : msg : \"{{ dict1_alternate['key1'] }}\" - name : An external variable debug : msg : \"{{ var1 }}\" Tip The vars_file directive can be used to load a set of variables from an existing YAML file. Execute the following command ansible-playbook playbook.yml","title":"Example 6"},{"location":"training/variables-facts/07/","text":"Example 7 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' bucket.json { \"list1\" : [ \"value1\" , \"value2\" , \"value3\" ], \"dict1\" : { \"key1\" : \"value1\" , \"key2\" : \"value2\" }, \"var1\" : \"var1_value\" } playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars_files : - bucket.json tasks : - name : An external variable stored in JSON format debug : msg : \"{{ var1 }}\" - name : An external dictionary stored in JSON format debug : msg : \"{{ dict1 }}\" - name : Accessing the dictionary using the Python syntax debug : msg : \"{{ dict1['key1'] }}\" - name : Accessing the dictionary using the dot notation debug : msg : \"{{ dict1.key1 }}\" - name : An external list stored in JSON format debug : msg : \"{{ list1 }}\" - name : Accessing the values using the Python syntax debug : msg : \"{{ list1[0] }}\" - name : Acccesing the values using the dot notation debug : msg : \"{{ list1.0 }}\" Tip The vars_file directive also accepts thje JSON file format. Execute the following command ansible-playbook playbook.yml","title":"Example 7"},{"location":"training/variables-facts/07/#example-7","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' bucket.json { \"list1\" : [ \"value1\" , \"value2\" , \"value3\" ], \"dict1\" : { \"key1\" : \"value1\" , \"key2\" : \"value2\" }, \"var1\" : \"var1_value\" } playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars_files : - bucket.json tasks : - name : An external variable stored in JSON format debug : msg : \"{{ var1 }}\" - name : An external dictionary stored in JSON format debug : msg : \"{{ dict1 }}\" - name : Accessing the dictionary using the Python syntax debug : msg : \"{{ dict1['key1'] }}\" - name : Accessing the dictionary using the dot notation debug : msg : \"{{ dict1.key1 }}\" - name : An external list stored in JSON format debug : msg : \"{{ list1 }}\" - name : Accessing the values using the Python syntax debug : msg : \"{{ list1[0] }}\" - name : Acccesing the values using the dot notation debug : msg : \"{{ list1.0 }}\" Tip The vars_file directive also accepts thje JSON file format. Execute the following command ansible-playbook playbook.yml","title":"Example 7"},{"location":"training/variables-facts/08/","text":"Example 8 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars_prompt : - name : first_name prompt : \"Enter your first name\" private : false tasks : - debug : msg : \"My first name is {{ first_name }}\" Tip You can use the vars_prompt directive to assign variables in runtime by creating a user prompt. Adding the private: false directive to the prompt makes the input visible. Execute the following command ansible-playbook playbook.yml Bonus round Remove the private directive and run the command again. Notice the change in behavior\"","title":"Example 8"},{"location":"training/variables-facts/08/#example-8","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars_prompt : - name : first_name prompt : \"Enter your first name\" private : false tasks : - debug : msg : \"My first name is {{ first_name }}\" Tip You can use the vars_prompt directive to assign variables in runtime by creating a user prompt. Adding the private: false directive to the prompt makes the input visible. Execute the following command ansible-playbook playbook.yml Bonus round Remove the private directive and run the command again. Notice the change in behavior\"","title":"Example 8"},{"location":"training/variables-facts/09/","text":"Example 9 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars_prompt : - name : user_password prompt : \"Enter your password\" encrypt : sha256_crypt confirm : true salt_size : 7 tasks : - debug : msg : \"This is the encrypted password: {{ user_password }}\" Tip For additional security the variables stored with vars_prompt can be encrypted. Execute the following command ansible-playbook playbook.yml Bonus round Check the official documentation for vars_prompt and try out other encryption algorithms.","title":"Example 9"},{"location":"training/variables-facts/09/#example-9","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false vars_prompt : - name : user_password prompt : \"Enter your password\" encrypt : sha256_crypt confirm : true salt_size : 7 tasks : - debug : msg : \"This is the encrypted password: {{ user_password }}\" Tip For additional security the variables stored with vars_prompt can be encrypted. Execute the following command ansible-playbook playbook.yml Bonus round Check the official documentation for vars_prompt and try out other encryption algorithms.","title":"Example 9"},{"location":"training/variables-facts/10/","text":"Example 10 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Accessing the hostvars debug : msg : \"{{ hostvars[inventory_hostname] }}\" Tip Ansible offers a set of built-in variables such as hostvars and inventory_hostname . Execute the following command ansible-playbook playbook.yml Bonus round Modify the playbook to return the value of ansible_host variable.","title":"Example 10"},{"location":"training/variables-facts/10/#example-10","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Accessing the hostvars debug : msg : \"{{ hostvars[inventory_hostname] }}\" Tip Ansible offers a set of built-in variables such as hostvars and inventory_hostname . Execute the following command ansible-playbook playbook.yml Bonus round Modify the playbook to return the value of ansible_host variable.","title":"Example 10"},{"location":"training/variables-facts/11/","text":"Example 11 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Accessing the hostvars debug : msg : \"{{ hostvars[inventory_hostname].ansible_user | default('ute') }}\" Tip Ansible offers a set of built-in filters which can be used inside the template clauses. One of the most commonly used is default . Execute the following command ansible-playbook playbook.yml Bonus round Change the ansible_user for host centos1 to root and run the command again.","title":"Example 11"},{"location":"training/variables-facts/11/#example-11","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Accessing the hostvars debug : msg : \"{{ hostvars[inventory_hostname].ansible_user | default('ute') }}\" Tip Ansible offers a set of built-in filters which can be used inside the template clauses. One of the most commonly used is default . Execute the following command ansible-playbook playbook.yml Bonus round Change the ansible_user for host centos1 to root and run the command again.","title":"Example 11"},{"location":"training/variables-facts/12/","text":"Example 12 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' files/samplefacts1.fact { \"jsonfacts\" : { \"key1\" : \"value1\" , \"key2\" : \"value2\" } } files/samplefacts2.fact [inifacts] key1 = value1 key2 = value2 playbook.yml - name : Example playbook hosts : provisioner tasks : - debug : msg : \"{{ ansible_local.samplefacts1.jsonfacts }}\" - debug : msg : \"{{ ansible_local.samplefacts2.inifacts }}\" Tip Ansible allows the user to set his custom facts in JSON or INI formats. The files need to have a .fact extension. Execute the following command ansible-playbook playbook.yml What is the expected output of the command ? The command will fail since we have not pointed the location of the newly created facts to Ansible. Bonus round Using the playbook-scope directive fact_path and special built-in variable {{ playbook_dir }} point Ansible towards the directory, where the custom facts are stored.","title":"Example 12"},{"location":"training/variables-facts/12/#example-12","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' files/samplefacts1.fact { \"jsonfacts\" : { \"key1\" : \"value1\" , \"key2\" : \"value2\" } } files/samplefacts2.fact [inifacts] key1 = value1 key2 = value2 playbook.yml - name : Example playbook hosts : provisioner tasks : - debug : msg : \"{{ ansible_local.samplefacts1.jsonfacts }}\" - debug : msg : \"{{ ansible_local.samplefacts2.inifacts }}\" Tip Ansible allows the user to set his custom facts in JSON or INI formats. The files need to have a .fact extension. Execute the following command ansible-playbook playbook.yml What is the expected output of the command ? The command will fail since we have not pointed the location of the newly created facts to Ansible. Bonus round Using the playbook-scope directive fact_path and special built-in variable {{ playbook_dir }} point Ansible towards the directory, where the custom facts are stored.","title":"Example 12"},{"location":"training/variables-facts/13/","text":"Example 13 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' files/samplefacts1.fact #!/bin/bash printf '{\"kernel_package\": \"%s\"}\\n' \" $( uname -r ) \" files/samplefacts2.fact #!/bin/bash echo [ kernel_package ] echo package = ` uname -r ` playbook.yml - name : Example playbook hosts : provisioner fact_path : \"{{ playbook_dir }}/files\" tasks : - debug : msg : \"{{ ansible_local.samplefacts1.kernel_package }}\" - debug : msg : \"{{ ansible_local.samplefacts2.kernel_package.package }}\" Tip Your custom facts can be executable scripts providing that they produce a valid JSON or INI output. Execute the following command ansible-playbook playbook.yml Bonus round Ansible looks for custom facts in /etc/ansible/facts.d on the remote hosts. Create a playbook that will copy one of the facts to centos1 and story it in the aformentioned directory as an executable under the name kernel.fact . Use the file module to make sure that the necessary directory exists and the copy module to send the fact file.","title":"Example 13"},{"location":"training/variables-facts/13/#example-13","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' files/samplefacts1.fact #!/bin/bash printf '{\"kernel_package\": \"%s\"}\\n' \" $( uname -r ) \" files/samplefacts2.fact #!/bin/bash echo [ kernel_package ] echo package = ` uname -r ` playbook.yml - name : Example playbook hosts : provisioner fact_path : \"{{ playbook_dir }}/files\" tasks : - debug : msg : \"{{ ansible_local.samplefacts1.kernel_package }}\" - debug : msg : \"{{ ansible_local.samplefacts2.kernel_package.package }}\" Tip Your custom facts can be executable scripts providing that they produce a valid JSON or INI output. Execute the following command ansible-playbook playbook.yml Bonus round Ansible looks for custom facts in /etc/ansible/facts.d on the remote hosts. Create a playbook that will copy one of the facts to centos1 and story it in the aformentioned directory as an executable under the name kernel.fact . Use the file module to make sure that the necessary directory exists and the copy module to send the fact file.","title":"Example 13"},{"location":"training/variables-facts/14/","text":"Example 14 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Set a custom fact set_fact : custom_fact : This is a custom fact - name : Print the custom fact debug : msg : \"{{ custom_fact }}\" Tip Another way to manipulate facts in runtime is the set_fact module. This allows the user to set facts in a dynamic manner. Execute the following command ansible-playbook playbook.yml","title":"Example 14"},{"location":"training/variables-facts/14/#example-14","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : centos1 gather_facts : false tasks : - name : Set a custom fact set_fact : custom_fact : This is a custom fact - name : Print the custom fact debug : msg : \"{{ custom_fact }}\" Tip Another way to manipulate facts in runtime is the set_fact module. This allows the user to set facts in a dynamic manner. Execute the following command ansible-playbook playbook.yml","title":"Example 14"},{"location":"training/variables-facts/15/","text":"Example 15 hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : provisioner gather_facts : false vars : vars_directory_content : \"{{ lookup('pipe', 'ls {{ playbook_dir }}')}}\" tasks : - name : Set the custom fact set_fact : fact_directory_content : \"{{ lookup('pipe', 'ls')}}\" - name : Initial value for vars_directory_content debug : msg : \"{{ vars_directory_content }}\" - name : Initial value for fact_directory_content debug : msg : \"{{ fact_directory_content }}\" - name : Add a file to the playbook directory file : state : touch dest : \"{{ playbook_dir}}/var_vs_fact\" - name : Post-modification value for vars_directory_content debug : msg : \"{{ vars_directory_content }}\" - name : Post-modification value for fact_directory_content debug : msg : \"{{ fact_directory_content }}\" Tip In Ansible vars and facts act in a different manner. Knowing when and how to use on of these concepts or another is key to successful playbook writing. Execute the following command ansible-playbook playbook.yml What is the expected output of the command ? The var will reflect the changes in the directory content. Variables are evaluated in runtime, whereas facts as the name suggests are set in stone.","title":"Example 15"},{"location":"training/variables-facts/15/#example-15","text":"hosts.yml centos : hosts : provisioner : ansible_connection : local centos1 : ansible_host : '192.168.77.22' ubuntu : hosts : ubuntu1 : ansible_host : '192.168.77.23' playbook.yml - name : Example playbook hosts : provisioner gather_facts : false vars : vars_directory_content : \"{{ lookup('pipe', 'ls {{ playbook_dir }}')}}\" tasks : - name : Set the custom fact set_fact : fact_directory_content : \"{{ lookup('pipe', 'ls')}}\" - name : Initial value for vars_directory_content debug : msg : \"{{ vars_directory_content }}\" - name : Initial value for fact_directory_content debug : msg : \"{{ fact_directory_content }}\" - name : Add a file to the playbook directory file : state : touch dest : \"{{ playbook_dir}}/var_vs_fact\" - name : Post-modification value for vars_directory_content debug : msg : \"{{ vars_directory_content }}\" - name : Post-modification value for fact_directory_content debug : msg : \"{{ fact_directory_content }}\" Tip In Ansible vars and facts act in a different manner. Knowing when and how to use on of these concepts or another is key to successful playbook writing. Execute the following command ansible-playbook playbook.yml What is the expected output of the command ? The var will reflect the changes in the directory content. Variables are evaluated in runtime, whereas facts as the name suggests are set in stone.","title":"Example 15"},{"location":"training/yaml/01/","text":"Example 1 yaml2python.py #!/usr/bin/env python import argparse import json import yaml from pprint import pformat from pygments import highlight from pygments.formatters import Terminal256Formatter from pygments.lexers import PythonLexer from pygments.lexers.data import JsonLexer , YamlLexer STYLE = 'rrt' def pprint_python ( obj ): print ( highlight ( pformat ( obj ), PythonLexer (), Terminal256Formatter ( style = STYLE ))) def pprint_json ( obj ): print ( highlight ( obj , JsonLexer (), Terminal256Formatter ( style = STYLE ))) def pprint_yaml ( obj ): print ( highlight ( obj , YamlLexer (), Terminal256Formatter ( style = STYLE ))) # PARSE ARGUMENTS parser = argparse . ArgumentParser () parser . add_argument ( '-f' , '--file' , help = \"path to a YAML file\" , type = str , default = 'template.yml' ) args = parser . parse_args () # PRINT THE ORIGINAL STRUCTURE TO THE TERMINAL print ( ' \\n ============================' ) print ( '*** ORIGINAL YAML FILE ***' ) print ( '============================ \\n ' ) pprint_yaml ( open ( args . file , 'r' ) . read ()) # PRINT THE JSON EQUIVALENT print ( ' \\n ============================' ) print ( '*** JSON FILE EQUIVALENT ***' ) print ( '============================ \\n ' ) pprint_json ( json . dumps ( yaml . load ( open ( args . file ), Loader = yaml . FullLoader ), indent = 4 , sort_keys = True )) # PRINT THE PYTHON INTERPRETATION OF THE FILE TO THE TERMINAL print ( ' \\n =============================' ) print ( '*** PYTHON INTERPRETATION ***' ) print ( '============================= \\n ' ) pprint_python ( yaml . load ( open ( args . file ), Loader = yaml . FullLoader )) Tip YAML is a widely used file format for storing configuration. However, some properties of YAML such as interpretation of boolean values can be misleading at times. Install the Python pygments package pip install pygments and execute python yaml2python.py","title":"Example 1"},{"location":"training/yaml/01/#example-1","text":"yaml2python.py #!/usr/bin/env python import argparse import json import yaml from pprint import pformat from pygments import highlight from pygments.formatters import Terminal256Formatter from pygments.lexers import PythonLexer from pygments.lexers.data import JsonLexer , YamlLexer STYLE = 'rrt' def pprint_python ( obj ): print ( highlight ( pformat ( obj ), PythonLexer (), Terminal256Formatter ( style = STYLE ))) def pprint_json ( obj ): print ( highlight ( obj , JsonLexer (), Terminal256Formatter ( style = STYLE ))) def pprint_yaml ( obj ): print ( highlight ( obj , YamlLexer (), Terminal256Formatter ( style = STYLE ))) # PARSE ARGUMENTS parser = argparse . ArgumentParser () parser . add_argument ( '-f' , '--file' , help = \"path to a YAML file\" , type = str , default = 'template.yml' ) args = parser . parse_args () # PRINT THE ORIGINAL STRUCTURE TO THE TERMINAL print ( ' \\n ============================' ) print ( '*** ORIGINAL YAML FILE ***' ) print ( '============================ \\n ' ) pprint_yaml ( open ( args . file , 'r' ) . read ()) # PRINT THE JSON EQUIVALENT print ( ' \\n ============================' ) print ( '*** JSON FILE EQUIVALENT ***' ) print ( '============================ \\n ' ) pprint_json ( json . dumps ( yaml . load ( open ( args . file ), Loader = yaml . FullLoader ), indent = 4 , sort_keys = True )) # PRINT THE PYTHON INTERPRETATION OF THE FILE TO THE TERMINAL print ( ' \\n =============================' ) print ( '*** PYTHON INTERPRETATION ***' ) print ( '============================= \\n ' ) pprint_python ( yaml . load ( open ( args . file ), Loader = yaml . FullLoader )) Tip YAML is a widely used file format for storing configuration. However, some properties of YAML such as interpretation of boolean values can be misleading at times. Install the Python pygments package pip install pygments and execute python yaml2python.py","title":"Example 1"}]}